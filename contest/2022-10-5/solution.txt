crop:
将点按(xi%3,yi%3)分类。
满足条件的点的组合只有3个点都来自一组或3个点来自不同的组2种情况。
那么就变成一个简单的组合计数问题了。

scalar:
一个显然的结论是：
x1<=x2<=..<=xn
y1>=y2>=..>=yn
假设在当前基础上交换yi和yj(i<j)的位置，那么
delta=xiyj+xjyi-xiyi-xjyj=(yj-yi)(xi-xj)>=0
所以解不会变优。

一个更加严谨的证明方式是假设当前的序列为任意不满足条件的序列，
那么有，某个xi和yi配对,x'=xi+1和y'配对且y'>=y,那么交换xi和xi+1后，
解不会变差，同时可以通过这种交换使得最终满足条件。所以这样的解是最优的。


perm:
类似于求某一个排列之前有多少个排列的方法。
这是个经典问题，在此不再多说。
本题的区别在于数不一定是不同的，但本质并没有什么不同。


desert:
设d[i][j]表示当前在(i,j),还需多久才能走到绿洲。
我们可以观察到，因为求的是最坏情况下的解，那么每个状态的决策只有两种
第一种是选择最优的一个相邻状态x，并用x+3更新答案，第二种是使用
次优的相邻状态x'，用x'+1更新答案。
这类似与经典的最短路问题，只是是倒着推的。
因为长,宽<=50,具体实现可以采用bellman-ford。


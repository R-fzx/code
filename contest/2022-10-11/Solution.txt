assembly:

送分题，范围很小，暴力搜索分给每个人多少礼品，然后直接2^n算概率就行了

road:

将所有的边按照A排序，然后从小到大依次加入，维护一颗关于B的最小生成树，用生成树内B最大的边和当前的A更新答案就行了

关于最小生成树的维护其实可以暴力...只需要一个能支持删除操作的邻接表就行了

直接O(n)找到新加入边两节点路径上的最大边，看是不是能被当前边替换掉

这样做的复杂度是O(nm)

painting:

仔细分析所有的合法染色方案可以发现它们都有这样的性质:

设最左边一列的颜色集合为A，最右边一列的颜色集合为B，中间的部分颜色集合为C

那么有:
1. C∈A∩B
2. |A-B|=|B-A|

我们可以枚举i=|A∩B|以及j=|A-B|，那么按类别A∩B、A-B、B-A选出这些颜色总共有C(k,i) * C(k-i,j) * C(k-i-j,j) = k!/(k-2*j-i)!/j!/j!/i! 种方案

在颜色选定之后，中间部分填色的方案数是i^(n*(m-2))，而右边的方案数和左边的相同，都等于n个格子填i+j种颜色且每种颜色至少用一次的方案数

事实上n个格子填i+j种颜色且每种颜色至少用一次的方案数f[i+j]是可以通过DP预处理得到的
         i-1
f[i]=i^n-∑f[j]*c(i,j)
         1
因此在颜色选定之后，总的方案数就是f[i+j]^2*i^(n*(m-2))

所以最终的答案的就是
 n min(n-i,(k-i)/2)
 ∑      ∑       f[i+j]^2*i^(n*(m-2))*k!/(k-2*j-i)!/j!/j!/i!
i=0     j=0

复杂度为O(n^2+nm)，常数有点大